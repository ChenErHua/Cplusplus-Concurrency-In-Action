## __4. C++ 标准库的变更__ ##

### 4.1 变长参数模板 ###

### 4.2 新的字符串字面值 ###

### 4.3 用户自定义的字面值 ###

### 4.4 多线程内存模型 ###

### 4.5 线程本地存储 ###

### 4.6 显式地使用或禁用某些特殊成员函数（构造函数，拷贝构造，赋值操作符，析构等） ###

### 4.7 long long int类型 ###

### 4.8 继承构造/委托构造 ###

继承构造。C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。注意：继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量。如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数。一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数
  class A
  {
  public:
      A(int i) { std::cout << "i = " << i << std::endl; }
      A(double d, int i) {}
      A(float f, int i, const char* c) {}
      // ...
  };
  class B : public A
  {
  public:
      using A::A; // 继承构造函数
      // ...
      virtual void ExtraInterface(){}
  };
  
委托构造和继承构造函数类似，委托构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。// 如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这必须通过初始化列表进行操作，如下：
  class Info
  {
  public:
      Info() : Info(1) { }    // 委托构造函数
      Info(int i) : Info(i, 'a') { } // 既是目标构造函数，也是委托构造函数
      Info(char e): Info(1, e) { }
  private:
      Info(int i, char e): type(i), name(e) { /\* 其它初始化 \*/} // 目标构造函数      
      int  type;
      char name;
      // ...
  };

### 4.9 静态断言 assertions ###

### 4.10 允许 sizeof 运算符作用在类型的数据成员上，无须明确的对象 ###

### 4.11 垃圾回收机制 ###

### 4.12 属性 ###


