本小节介绍 std::mutex 的用法。

## 4.2 互斥量详解 ##

### 4.2 `std::mutex` 介绍 ###

`std::mutex` 是 C++11 中最基本的互斥量，`std::mutex` 对象提供了独占所有权的特性——即不支持递归地对 `std::mutex` 对象上锁，而 `std::recursive_lock` 则可以递归地对互斥量对象上锁。

### `std::mutex` 的成员函数 ###

- 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。
- lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。
- unlock()， 解锁，释放对互斥量的所有权。
- try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，

    1. 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。
    2. 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。
    3. 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。

下面给出一个与 std::mutex 的小例子（[参考](http://www.cplusplus.com/reference/mutex/mutex/try_lock/)）

    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex

    volatile int counter(0); // non-atomic counter
    std::mutex mtx;           // locks access to counter

    void attempt_10k_increases() {
        for (int i=0; i<10000; ++i) {
            if (mtx.try_lock()) {   // only increase if currently not locked:
                ++counter;
                mtx.unlock();
            }
        }
    }

    int main (int argc, const char* argv[]) {
        std::thread threads[10];
        for (int i=0; i<10; ++i)
            threads[i] = std::thread(attempt_10k_increases);

        for (auto& th : threads) th.join();
        std::cout << counter << " successful increases of the counter.\n";

        return 0;
    }    
经过多次运行，可以发现counter的值基本集中在3W多，4W多，5W多，而如果不用try_lock(),使用lock()，counter的值一定是100000。

### `std::recursive_mutex` 介绍 ###

`std::recursive_mutex` 与 `std::mutex `一样，也是一种可以被上锁的对象，但是和 `std::mutex` 不同的是，`std::recursive_mutex` 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，`std::recursive_mutex` 释放互斥量时需要调用与该锁层次深度相同次数的 `unlock()`，可理解为 `lock()` 次数和 `unlock()` 次数相同，除此之外，`std::recursive_mutex` 的特性和 `std::mutex` 大致相同。

    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex

    class counter
    {
    public:
        counter() : count(0) { }
    
        int add(int val) {
            std::recursive_mutex::scoped_lock scoped_lock(mutex);
            count += val;
            return count;
        }   
        int increment() {
            std::recursive_mutex::scoped_lock scoped_lock(mutex);
            return add(1);
        }
    
    private:
        boost::recursive_mutex mutex;
        int count;
    };
    
    counter c;
    
    void change_count(void*)
    {
        std::cout << "count == " << c.increment() << std::endl;
    }
    
    int main(int, char*[])
    {
    
        std::thread threads[10];
        // spawn 10 threads:
        for (int i=0; i<10; ++i)
            threads[i] = std::thread(change_count, 0);
    
        for (auto& th : threads) th.join();
       
        return 0;
    }

### std::time_mutex 介绍 ###

`std::time_mutex` 比 `std::mutex` 多了两个成员函数，`try_lock_for()`，`try_lock_until()`。

`try_lock_for` 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 `std::mutex` 的 `try_lock()` 不同，try_lock 如果被调用时没有获得锁则直接返回 `false`），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 `false`。

`try_lock_until` 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 `false`。

下面的小例子说明了 `std::time_mutex` 的用法（[参考](http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/)）。

    #include <iostream>       // std::cout
    #include <chrono>         // std::chrono::milliseconds
    #include <thread>         // std::thread
    #include <mutex>          // std::timed_mutex

    std::timed_mutex mtx;

    void fireworks() {
        // waiting to get a lock: each thread prints "-" every 200ms:
        while (!mtx.try_lock_for(std::chrono::milliseconds(200))) {
            std::cout << "-";
        }

        // got a lock! - wait for 1s, then this thread prints "*"
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        std::cout << "*\n";
        mtx.unlock();
    }

    int main ()
    {
        std::thread threads[10];
        // spawn 10 threads:
        for (int i=0; i<10; ++i)
            threads[i] = std::thread(fireworks);

        for (auto& th : threads) th.join();

        return 0;
    }

### `std::recursive_timed_mutex` 介绍 ###

和 `std:recursive_mutex` 与 `std::mutex` 的关系一样，`std::recursive_timed_mutex` 的特性也可以从 `std::timed_mutex` 推导出来，感兴趣的同鞋可以自行查阅。;-)

### std::lock_guard 介绍 ###

与 Mutex RAII 相关，方便线程对互斥量上锁。例子（[参考](http://www.cplusplus.com/reference/mutex/lock_guard/)）:

           #include <iostream>
        #include <mutex>
        std::mutex mutex;
        void safe_thread() {
            try {
                std::lock_guard<std::mutex> _guard(mutex);
                throw std::logic_error("logic error");
            } catch (std::exception &ex) {
                std::cerr << "[caught] " << ex.what() << std::endl;
            }
        }
        int main() {
            safe_thread();
            // 此处仍能上锁
            mutex.lock();
            std::cout << "OK, still locked" << std::endl;
            mutex.unlock();

            return 0;
        }
<br> [caught] logic error </br>
OK, still locked

### `std::unique_lock` 介绍 ###

与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。例子（[参考](http://www.cplusplus.com/reference/mutex/unique_lock/)）：

    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex, std::unique_lock

    std::mutex mtx;           // mutex for critical section

    void print_block (int n, char c) {
        // critical section (exclusive access to std::cout signaled by lifetime of lck):
        std::unique_lock<std::mutex> lck (mtx);
        for (int i=0; i<n; ++i) {
            std::cout << c;
        }
        std::cout << '\n';
    }

    int main ()
    {
        std::thread th1 (print_block,50,'*');
        std::thread th2 (print_block,50,'$');

        th1.join();
        th2.join();

        return 0;
    }  
 
 ### 使用层次锁来避免死锁: ###

虽然这实际上是定义锁定顺序的一个特例,但锁层次能提供一种方法,来检查运行时是否遵循约定.其思路是将应用程序分层,当代码试图锁定一个互斥元时,如果它在较低层已经持有锁定.那么就不允许它锁定该互斥元.下面是代码实现:

      class hierarchical_mutex
      {
        std::mutex internal_mutex;        
        unsigned long const hierarchy_value;
        unsigned long previous_hierarchy_value;
        static thread_local unsigned long this_thread_hierarchy_value;
        void check_for_hierarchy_violation()// violated违反
        { // 当前线程锁定了更低等级的或者是同等级的锁
        if(this_thread_hierarchy_value <= hierarchy_value)
         {
            throw std::logic_error(“mutex hierarchy violated”); 
         }
        }
       void update_hierarchy_value()
        {
          previous_hierarchy_value=this_thread_hierarchy_value;
          this_thread_hierarchy_value=hierarchy_value;
        }
       public:
        explicit hierarchical_mutex(unsigned long value):
              hierarchy_value(value),previous_hierarchy_value(0) {}
          void lock()
          {
            check_for_hierarchy_violation();
            internal_mutex.lock();
            update_hierarchy_value();
          }
          void unlock()
          {
            this_thread_hierarchy_value=previous_hierarchy_value;
            internal_mutex.unlock();
          }
          bool try_lock()
          {
            check_for_hierarchy_violation();
            if(!internal_mutex.try_lock())
            return false;
            update_hierarchy_value();
            return true;
          }
      };
      thread_local unsigned long hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);

### Using a lock hierarchy to prevent deadlock ###

    hierarchical_mutex high_level_mutex(10000);
    hierarchical_mutex low_level_mutex(5000);
    int do_low_level_stuff();
    int low_level_func()
    {
      std::lock_guard<hierarchical_mutex> lk(low_level_mutex);
      return do_low_level_stuff();
    }
    void high_level_stuff(int some_param);
    void high_level_func()
    {
      std::lock_guard<hierarchical_mutex> lk(high_level_mutex);//lk是用同一个实例？是high_level_stuff(low_level_func());
    }
    void thread_a()/成功
    {
      high_level_func();
    }
    hierarchical_mutex other_mutex(100);
    void do_other_stuff();
    void other_stuff()
    {
      high_level_func();
      do_other_stuff();
    }
    void thread_b()//失败
    {
      std::lock_guard<hierarchical_mutex> lk(other_mutex);
      other_stuff();
    }

### Using a lock hierarchy to swap ###

    struct Data {
      hierarchical_mutex m;
      int data; 
      Data(unsigned long hierarchical, int data) 
        :m(hierarchical), data(data) {}
      void swap(Data & d) 
      {
        lock_guard<hierarchical_mutex> lock1(m);
        std::chrono::seconds dura(1);
        std::this_thread::sleep_for(dura);
        lock_guard<hierarchical_mutex> lock2(d.m);
        std::swap(d.data, data);// T c(std::move(a)); a=std::move(b); b=std::move(c);
      }
    }; 
    int main()
    {
      Data d1(10000,1), d2(1000,2);
      {
        thread_guard t1(thread([&] {
          try
          {
            d1.swap(d2);
          }
          catch (const std::exception&)
          {
            cout << "operation not be permitted!" << endl;
          }			
        }));
        thread_guard t2(thread([&] {
          try
          {
            d2.swap(d1);
          }
          catch (const std::exception&)
          {
            cout << "operation not be permitted!" << endl;
          }
        }));
      }
      cout << d1.data << endl;
    }

